/*
Есть набор точек с координатами (x, y). Нужно написать функцию кластеризации точек, которая объединяет близколежащие друг к другу точки вместе.

    Пример точек

Алгоритм данной функции должен быть следующим:

    Пусть точки разбросаны на области размером 200x200, т.е. координаты всех точек по X и по Y лежат в диапазоне от -100 до 100.
Зададим область кластеризации (на рисунке выглядит как сетка) с координатами центра (x0, y0) и размером zoom
относительно общего размера области точек. Если (x0, y0) = (0, 0) И zoom = 1, то все точки попадут в область кластеризации
(т.е. область кластеризации будет по X от -100 до 100, по Y от -100 до 100). Если же zoom равен 2, то область
кластеризации покроет только четверть площади области точек (т.е. область кластеризации будет по X от -50 до 50, по Y от -50 до 50).
После того, как мы определились с размерами и положением области кластеризации, разбиваем её на 10 частей по X, и на 10 частей по Y.
    Для каждой получившейся ячейки считаем, сколько точек попало в неё. На рисунке ячейки с точками показаны серым.
    Если точка попала на вертикальную границу двух ячеек, то считаем, что она попадает в правую из них. Если точка попала на горизонтальную
    границу двух ячеек, то считаем, что она попадает в нижнюю из них.
    Нумерация ячеек сверху вниз (j от 0 до 9), слева направо (i от 0 до 9).
Ответом является массив объектов вида { i: 6, j: 2, count: 2 }, где count — количество попавших в ячейку (i, j) точек, для ячеек,
в которых есть хотя бы одна точка. Массив должен быть отсортирован сначала по увеличению строки j, потом по столбцу i.
    Файл с ответом должен экспортировать функцию с четырьмя параметрами:
 */



/**
 * Функция кластеризации
 * @param points { { x: number; y: number }[] } массив точек
 * @param x0 { number } центр области кластеризации по X
 * @param y0 { number } центр области кластеризации по Y
 * @param zoom { number } масштаб увеличения области кластеризации
 *
 * @return { i: number; j: number; count: number }[]
 */
module.exports = function(points, x0, y0, zoom) {
    // ваш код
    const zoomedLength = 200 / zoom / 2
    const bounds = {
        x: {min: x0 - zoomedLength, max: x0 + zoomedLength},
        y: {min: y0 - zoomedLength, max: y0 + zoomedLength}
    }
    const clusters = [].concat(...new Array(10)
        .fill(0)
        .map((_, i) =>
            new Array(10)
                .fill(0)
                .map((_, j) => ({
                    i,
                    j,
                    count: 0,
                    leftBound: bounds.x.min + i * zoomedLength / 5,
                    rightBound: bounds.x.min + (i + 1) * zoomedLength / 5,
                    topBound: bounds.y.min + j * zoomedLength / 5,
                    bottomBound: bounds.y.min + (j + 1) * zoomedLength / 5
                }))
        )
    )

    points.forEach(point => {
        const index = clusters.findIndex(a =>
            a.leftBound <= point.x &&
            a.rightBound > point.x &&
            a.topBound <= point.y &&
            a.bottomBound > point.y
        )
        if(index >= 0) clusters[index].count += 1
    })
    //.map(x => ({i: x.i, j: x.j, count: x.count}))
    return clusters.filter(x => x.count > 0).map(x => ({i: x.i, j: x.j, count: x.count})).sort((a, b) => a.j - b.j || a.i - b.i)
}